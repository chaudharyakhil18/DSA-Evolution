# DSA Patterns Practice

A curated collection of data structures and algorithms (DSA) problems organized by **patterns**.

The goal of this repository is to:

- Build deep intuition around core problem-solving patterns (not just memorize solutions).
- Track progress across difficulties and topics in a structured way.
- Maintain a clean, showcase-ready portfolio of DSA practice.
- Have a quick reference to revisit before interviews, contests, or reviews.

---

## ðŸ“š Table of Contents

Each folder focuses on one core DSA pattern and contains problems plus a pattern-specific README.

- [Arrays & Hashing](./arrays-hashing/)
- [Two Pointers](./two-pointers/)
- [Sliding Window](./sliding-window/)
- [Stack & Queue](./stack-queue/)
- [Linked List](./linked-list/)
- [Trees](./trees/)
- [Graphs](./graphs/)
- [Dynamic Programming](./dynamic-programming/)
- [Greedy](./greedy/)
- [Backtracking](./backtracking/)
- [Heaps & Priority Queues](./heaps-priority-queues/)
- [Intervals](./intervals/)
- [Binary Search](./binary-search/)
- [Bit Manipulation](./bit-manipulation/)

---

## ðŸ“ˆ Progress Tracker

Overall view of how many problems have been solved by difficulty.

> Update these numbers as you add more problems to each pattern.

| Difficulty | Solved |
|-----------|--------|
| Easy      | 0      |
| Medium    | 0      |
| Hard      | 0      |

You can optionally break this down per pattern later, for example:

- Arrays & Hashing: `0E / 0M / 0H`
- Dynamic Programming: `0E / 0M / 0H`

---

## ðŸŽ¯ Learning Goals Tracker

High-level learning goals for each major DSA pattern.

- [ ] **Arrays & Hashing** â€“ frequency maps, prefix sums, in-place operations, common tricks (two-sum, subarray sums, etc.).
- [ ] **Two Pointers** â€“ opposite ends pointers, fast/slow pointers, partitioning, in-place removal, pair problems.
- [ ] **Sliding Window** â€“ fixed and variable windows, counting/maximum/minimum subarrays, using hash maps in windows.
- [ ] **Stack & Queue** â€“ monotonic stacks, expression evaluation, BFS patterns, queue-based processing.
- [ ] **Linked List** â€“ pointer manipulation, cycle detection, reversing, merging, splitting lists.
- [ ] **Trees** â€“ DFS/BFS traversals, recursion patterns, BST properties, tree DP, serialization.
- [ ] **Graphs** â€“ adjacency lists, BFS/DFS, topological sort, connected components, shortest paths (BFS / Dijkstra).
- [ ] **Dynamic Programming** â€“ 1D/2D DP, state definitions, transitions, tabulation vs memoization, optimization tricks.
- [ ] **Greedy** â€“ local vs global optimality, sorting-based greedy, intervals, scheduling problems.
- [ ] **Backtracking** â€“ recursion trees, generating subsets/permutations, constraints pruning.
- [ ] **Heaps & Priority Queues** â€“ top-k problems, merging, streaming data, scheduling with priorities.
- [ ] **Intervals** â€“ merging, insertion, overlap checks, sweep-line style reasoning.
- [ ] **Binary Search** â€“ search on answer, custom conditions, edge-case handling, monotonic predicates.
- [ ] **Bit Manipulation** â€“ masks, toggling bits, subsets via bits, XOR tricks.

Feel free to mark items as **in progress** or **done** as you grow more comfortable with each pattern.

---

## ðŸ§­ How to Use This Repository

1. Pick a pattern you want to strengthen (for example, [Sliding Window](./sliding-window/)).
2. Solve or add a problem in that patternâ€™s folder.
3. Document the problem in the pattern-specific `README.md` under its table:
   - Link to the solution file.
   - Note the platform (e.g., LeetCode, Codeforces).
   - Mark the difficulty.
   - Write a one-line summary of the key idea.
4. Update the **Progress Tracker** and optionally the **Learning Goals** once you feel confident.

This way, the repo stays clean, organized, and ready to showcase your DSA journey.